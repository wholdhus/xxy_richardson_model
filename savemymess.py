L = int(sys.argv[1])
N = int(sys.argv[2])
g_step = float(sys.argv[3])
G = 1.1/(L-2*N+1)
# G = 2.0/(1-N+L/2)
k, epsilon_rgk = rgk_spectrum(L, 1, 0)
# epsilon = k**2
epsilon = k**3
plt.figure(figsize=(12,8))
plt.subplot(2,1,1)
# E, n, Delta, Gs = compute_hyperbolic_energy(L, N, G, epsilon, g_step)
# plt.scatter(Gs, E, s=8)
E2, n2, Delta2, G2, Z = compute_hyperbolic_energy(L, N, G, epsilon, g_step,
        start=0.9, use_fd=False)
plt.scatter(G2, E2, s=2)
plt.axvline(1./(L-2*N+1), color='g')
# plt.axvline(2./(L-2*N+1), color='m')
# plt.axvline(-2./(N-1), color = 'y')
# plt.ylim(275, 285)

# plt.subplot(3,1,2)
# de = np.gradient(E2, G2)
# d2e = np.gradient(de, G2)
# d3e = np.gradient(d2e, G2)
# plt.scatter(G2[10:-10], d3e[10:-10])

plt.subplot(2,1,2)
nsN = np.array([ns[N-1] for ns in n2])
nsN1 = np.array([ns[N] for ns in n2])
qp = nsN - nsN1
plt.scatter(G2, qp, s=2)
plt.scatter(G2, nsN, s=2)
plt.scatter(G2, nsN1, s=2)
plt.axvline(1./(L-2*N+1), color = 'g')
plt.axvline(1./(L-N+1), color = 'r')
# plt.axvline(-2./(N-1), color = 'y')
# plt.axvline(2./(L-2*N+1), color = 'm')
plt.ylim(0, 1)
plt.show()
